package experiment

import (
	ifaces "phenix/types/interfaces"
	"phenix/util/common"
)

type CreateOption func(*createOptions)

type createOptions struct {
	name        string
	annotations map[string]string
	topology    string
	scenario    string
	vlanMin     int
	vlanMax     int
	vlanAliases map[string]int
	schedules   map[string]string
	baseDir     string
}

func newCreateOptions(opts ...CreateOption) createOptions {
	var o createOptions

	for _, opt := range opts {
		opt(&o)
	}

	if o.baseDir == "" {
		o.baseDir = common.PhenixBase + "/experiments/" + o.name
	}

	return o
}

func CreateWithName(n string) CreateOption {
	return func(o *createOptions) {
		o.name = n
	}
}

func CreateWithAnnotations(a map[string]string) CreateOption {
	return func(o *createOptions) {
		o.annotations = a
	}
}

func CreateWithTopology(t string) CreateOption {
	return func(o *createOptions) {
		o.topology = t
	}
}

func CreateWithScenario(s string) CreateOption {
	return func(o *createOptions) {
		o.scenario = s
	}
}

func CreateWithVLANMin(m int) CreateOption {
	return func(o *createOptions) {
		o.vlanMin = m
	}
}

func CreateWithVLANMax(m int) CreateOption {
	return func(o *createOptions) {
		o.vlanMax = m
	}
}

func CreateWithVLANAliases(a map[string]int) CreateOption {
	return func(o *createOptions) {
		o.vlanAliases = a
	}
}

func CreateWithSchedules(s map[string]string) CreateOption {
	return func(o *createOptions) {
		o.schedules = s
	}
}

func CreateWithBaseDirectory(b string) CreateOption {
	return func(o *createOptions) {
		o.baseDir = b
	}
}

type SaveOption func(*saveOptions)

type saveOptions struct {
	name string

	spec   ifaces.ExperimentSpec
	status ifaces.ExperimentStatus

	saveNilSpec   bool
	saveNilStatus bool
}

func newSaveOptions(opts ...SaveOption) saveOptions {
	var o saveOptions

	for _, opt := range opts {
		opt(&o)
	}

	return o
}

func SaveWithName(n string) SaveOption {
	return func(o *saveOptions) {
		o.name = n
	}
}

func SaveWithSpec(s ifaces.ExperimentSpec) SaveOption {
	return func(o *saveOptions) {
		o.spec = s
	}
}

func SaveWithStatus(s ifaces.ExperimentStatus) SaveOption {
	return func(o *saveOptions) {
		o.status = s
	}
}

func SaveWithNilSpec(s bool) SaveOption {
	return func(o *saveOptions) {
		o.saveNilSpec = s
	}
}

func SaveWithNilStatus(s bool) SaveOption {
	return func(o *saveOptions) {
		o.saveNilStatus = s
	}
}

type ScheduleOption func(*scheduleOptions)

type scheduleOptions struct {
	name      string
	algorithm string
}

func newScheduleOptions(opts ...ScheduleOption) scheduleOptions {
	var o scheduleOptions

	for _, opt := range opts {
		opt(&o)
	}

	return o
}

func ScheduleForName(n string) ScheduleOption {
	return func(o *scheduleOptions) {
		o.name = n
	}
}

func ScheduleWithAlgorithm(a string) ScheduleOption {
	return func(o *scheduleOptions) {
		o.algorithm = a
	}
}

type StartOption func(*startOptions)

type startOptions struct {
	name    string
	dryrun  bool
	vlanMin int
	vlanMax int
	errChan chan error

	// Option to treat all errors generated by minimega as warnings when launching
	// an experiment.
	mmErrAsWarn bool
}

func newStartOptions(opts ...StartOption) startOptions {
	var o startOptions

	for _, opt := range opts {
		opt(&o)
	}

	return o
}

func StartWithName(n string) StartOption {
	return func(o *startOptions) {
		o.name = n
	}
}

func StartWithDryRun(d bool) StartOption {
	return func(o *startOptions) {
		o.dryrun = d
	}
}

func StartWithVLANMin(m int) StartOption {
	return func(o *startOptions) {
		o.vlanMin = m
	}
}

func StartWithVLANMax(m int) StartOption {
	return func(o *startOptions) {
		o.vlanMax = m
	}
}

func StartWithErrorChannel(c chan error) StartOption {
	return func(o *startOptions) {
		o.errChan = c
	}
}

func StartWithMMErrorsAsWarnings(w bool) StartOption {
	return func(o *startOptions) {
		o.mmErrAsWarn = w
	}
}
